% the skeleton class represents a skeleton of a neuron
% with complicated structure
% it can read from a .xml file generated by KNOSSOS

classdef skeleton < handle

	properties
		% x, y & z coordinates of all nodes
		x
		y
		z

		edges % as defined in the original XML or hoc file
		A     % adjacency matrix, computed from edges

		% these properties are computed from the adjacency matrix
		branch_points 
		terminal_nodes
		source_nodes

		% determined by tracing processes using A
		processes
		process_lengths

		xml_file

		% neuron metrics
		tortuosity % per process


	end % end props

	methods

		function [s] = skeleton(path_to_skeleton)
			if nargin > 0
				if strfind(path_to_skeleton,'xml')
					s.xml_file = path_to_skeleton;
				elseif strfind(path_to_skeleton,'nml')
					s.xml_file = path_to_skeleton;
				% elseif strfind(path_to_skeleton,'hoc')
				% 	s.hoc_file = path_to_skeleton;
				end
			end

		end % end skeleton 

		function s = set.xml_file(s,value)
			% check if the file exists 
			assert(exist(value,'file') == 2,'XML file not found!')
			s.parseXML(value);
			s.traceProcesses;
			s.measureProcessLengths;
			s.measureTortuosity;
			s.xml_file = value;
		end % end set xml_file

		function h = hash(s)
			% hashes the contents of this skeleton object
			s = s(:);
			if length(s) > 1
				H = {};
				for j = 1:length(s)
					H{j} = s(j).hash;
				end
				h = dataHash(H);
			else
				P = properties(s);
				V = cell(length(P),1);
				for i = 1:length(P)
					try
						V{i} = dataHash(s.(P{i}));
					catch
					end
				end
				h = dataHash(V);
			end
		end

		function plot(s,show_individual_components)
			ax = gca; 
			hold(ax,'on')
			if nargin < 2
				show_individual_components = false;
			end
			if ~show_individual_components
				% only 1 component -- all good
				% plot all the processes with nodes
				for i = 1:size(s.processes,2)
					this_process = s.processes(1:find(~isnan(s.processes(:,i)),1,'last'),i);
					plot3(ax,s.x(this_process),s.y(this_process),s.z(this_process),'Color',[.8 .8 .8])
				end

				% plot3(s.x(~s.branch_points),s.y(~s.branch_points),s.z(~s.branch_points),'.','Color',[.9 .9 .9])

				% plot the branch points in blue
				plot3(ax,s.x(s.branch_points),s.y(s.branch_points),s.z(s.branch_points),'b.','MarkerSize',4)


				% mark the destination nodes in red
				plot3(ax,s.x(s.terminal_nodes),s.y(s.terminal_nodes),s.z(s.terminal_nodes),'r.','MarkerSize',4)

			else
				% list the sizes of the components
				C = conncomp(graph(s.A));
				n_comp = length(unique(C));
				for i = 1:n_comp
					disp(['# of nodes in component ' oval(i) ': ' oval(sum(C==i))])
				end
				% just plot the components in different colors
				c = lines();

				for j = 1:n_comp
					for i = 1:size(s.processes,2)
						this_process = s.processes(1:find(~isnan(s.processes(:,i)),1,'last'),i);
						this_process = intersect(this_process,find(C==j));
						if ~isempty(this_process)
							plot3(ax,s.x(this_process),s.y(this_process),s.z(this_process),'Color',c(j,:))
						end
					end
				end

			end
			% plot the first node in blank
			plot3(ax,s.x(1),s.y(1),s.z(1),'k.','MarkerSize',30)

		end

		function getComponentEndpoints(s)
			% for each component, show the number of nodes in it and show at least one end point 
			disp('This file name:')
			disp(s.xml_file)
			[C,n_comp] = s.findComponents;
			disp(['This graph has ' oval(n_comp)  ' components'])
			for i = 1:n_comp

				disp(['# of nodes in component ' oval(i) ': ' oval(sum(C==i))])
				disp('Some end points are:')
				ep = find((sum(full(s.A)) == 1).*(C == i));
				z = min([length(ep) 10]);
				disp('Node     X     Y    Z')
				for j = 1:z
					disp([oval(ep(j)) '    ' oval(s.x(ep(j)))  '    ' oval(s.y(ep(j)))  '    ' oval(s.z(ep(j)))])
				end
			end
		end % end getComponentEndpoints

		function measureProcessLengths(s)
			% find the length of each process along the process

			process_lengths = 0*s.processes;
			
			for i = 1:length(s.terminal_nodes)
				this_process_length = 0;
				nodes_in_this_process = s.processes(1:find(isnan(s.processes(:,i)),1,'first')-1,i);
				for j = 2:length(nodes_in_this_process)
					a = nodes_in_this_process(j-1);
					z = nodes_in_this_process(j);
					p1 = [s.x(a) s.y(a) s.z(a)];
					p2 = [s.x(z) s.y(z) s.z(z)];
					this_process_length = this_process_length + sqrt(sum((p1 - p2).^2));
					process_lengths(j,i) = this_process_length;
				end
				
			end
			s.process_lengths = process_lengths;

		end

		function measureTortuosity(s)
			% measures the tortuosity for each process
			s.tortuosity = NaN*s.terminal_nodes;

			for i = 1:length(s.terminal_nodes)
				% find the first and last nodes
				this_process_length = nanmax(s.process_lengths(:,i));
				if this_process_length > 0
					nodes_in_this_process = s.processes(1:find(isnan(s.processes(:,i)),1,'first')-1,i);
					a = nodes_in_this_process(1);
					z = nodes_in_this_process(end);
					p1 = [s.x(a) s.y(a) s.z(a)];
					p2 = [s.x(z) s.y(z) s.z(z)];
					euclidean_dist = sqrt(sum((p1 - p2).^2));
					s.tortuosity(i) = this_process_length/euclidean_dist;
				end
			end
		end % end measureTortuosity


		function traceProcesses(s)
			% traces the processes using the adjacency matrix, starting from node ID 1

			calling_func = dbstack;
			being_published = 0;
			if ~isempty(calling_func)
				if find(strcmp('publish',{calling_func.name}))
					being_published = 1;
				end
			end
			if ~being_published
				cprintf('green','[INFO] ')
	            fprintf('Tracing processes...\n')
	
			end

			processes = NaN(length(s.x),length(s.terminal_nodes));

			% for each terminal, trace the process back to...something
			for i = 1:length(s.terminal_nodes)
				this_node = s.terminal_nodes(i);
				this_path = NaN(length(s.z),1);
				c = 1;
				while ~isempty(this_node)
					this_path(c) = this_node;

					% find the parent of this node, and move to that
					this_node = s.edges(1,find(s.edges(2,:) == this_node));
					if length(this_node) > 1
						this_node = this_node(1);
					end
					c = c + 1;
					
					% check to make sure this node wasn't encountered before
					if length(this_path(1:c-1)) ~= length(unique(this_path(1:c-1)))
						cprintf('red','[WARN] ')
	            		fprintf('Loop detected! Aborting this process...\n')
	            		c = c - 1;
	            		this_node = [];
					end
				end
				processes(1:c-1,i) = flipud(this_path(1:c-1));
			end
			s.processes = processes;

		end % end traceProcesses


		function parseXML(s,path_name)
			lines = lineRead(path_name);
			n_nodes = sum(~cellfun(@isempty,(cellfun(@(x) strfind(x,'node id'),lines,'UniformOutput',false))));
			% make arrays
			x = NaN(1,n_nodes);
			y = x;
			z = x;
			branch_points = false(1,n_nodes);

			lines_with_nodes = find(~cellfun(@isempty,(cellfun(@(x) strfind(x,'node id'),lines,'UniformOutput',false))));

			for i = 1:length(lines_with_nodes)
				this_line = lines{lines_with_nodes(i)};
				double_quotes = strfind(this_line,'"');
				this_node = str2double(this_line(double_quotes(1)+1:double_quotes(2)-1));
				this_x = str2double(this_line(double_quotes(5)+1:double_quotes(6)-1));
				this_y = str2double(this_line(double_quotes(7)+1:double_quotes(8)-1));
				this_z = str2double(this_line(double_quotes(9)+1:double_quotes(10)-1));
				assert(~isnan(this_x),'Failed to extract X info from this node')
				assert(~isnan(this_y),'Failed to extract Y info from this node')
				assert(~isnan(this_z),'Failed to extract Z info from this node')

				x(this_node) = this_x;
				y(this_node) = this_y;
				z(this_node) = this_z;
			end
			
			% now get the branch points
			lines_with_branch_points = find(~cellfun(@isempty,(cellfun(@(x) strfind(x,'branchpoint id'),lines,'UniformOutput',false))));

			for i = 1:length(lines_with_branch_points)
				this_line = lines{lines_with_branch_points(i)};
				double_quotes = strfind(this_line,'"');
				branch_points((str2double(this_line(double_quotes(1)+1:double_quotes(2)-1)))) = true;
			end


			% then get the edges
			lines_with_edges = find(~cellfun(@isempty,(cellfun(@(x) strfind(x,'edge source'),lines,'UniformOutput',false))));
			edges = NaN(2,length(lines_with_edges));

			for i = 1:length(lines_with_edges)
				this_line = lines{lines_with_edges(i)};
				double_quotes = strfind(this_line,'"');
				edges(1,i) = str2double(this_line(double_quotes(1)+1:double_quotes(2)-1));
				edges(2,i) = str2double(this_line(double_quotes(3)+1:double_quotes(4)-1));
			end

			s.x = x;
			s.y = y;
			s.z = z;

			% make sure there are no super long edges 
			edge_lengths = NaN(1,length(edges));
			for i = 1:length(edge_lengths)
				a = edges(1,i);
				b = edges(2,i);
				edge_lengths(i) = sqrt((x(a)-x(b))^2 + (y(a)-y(b))^2 + (z(a)-z(b))^2);
			end

			s.edges = edges;
			% s.branch_points = logical(branch_points);

			% now convert the edges into a giant sparse adjacencey matrix
			% ignoring directed edges
			A = sparse(zeros(length(x)));
			for i = 1:size(edges,2)
				source = edges(1,i);
				dest = edges(2,i);
				A(source,dest) = 1;
			end
			A = A + A';
			A(A > 1) = 1;
			s.A = (A);

			[C,n_comp] = s.findComponents;


			calling_func = dbstack;
			being_published = 0;
			if ~isempty(calling_func)
				if find(strcmp('publish',{calling_func.name}))
					being_published = 1;
				end
			end
			if ~being_published
				if n_comp == 1
					cprintf('green','[INFO] ')
	                fprintf('Only one connected component!\n')
				else
					cprintf('red','[WARN] ')
	                fprintf('More than one connected component!\n')
				end
			end

			% now find the branch points, terminal points etc
			s.terminal_nodes = find(full(sum(A)) == 1);
			s.branch_points = find(full(sum(A)) > 2);


		end % end parseXML

		function [C,n_comp] = findComponents(s)
						% check that there is only one component
			G = graph(s.A);
			C = conncomp(G);

			% there exist nodes with no edges -- they effectively don't exist. so if there are components with only phantom nodes, ignore them
			for i = 1:length(unique(C))
				if all(isnan(s.x(find(C==i))))
					C(C==i) = NaN;
				end
			end

			% also ignore components with just one node -- not very important
			for i = 1:length(unique(C))
				if sum(C==i) == 1
					C(C==i) = NaN;
				end
			end
			n_comp = length(unique(nonnans(C)));

		end

	end

end % end classdef





